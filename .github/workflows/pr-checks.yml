1759808816537_image.png
1759808829195_image.png

package pr.pathguard import rego.v1 # -------- helpers -------- norm_path(p) := replace(p, "\\", "/") debug_enabled if { input.debug == true } valid_files if { input.files; is_array(input.files) } valid_actor_teams if { input.actor_teams; is_array(input.actor_teams) } # -------- actor t

pasted


Skip to content Navigation Menu uday-test auth0-domain1 Type / to search Code Issues Pull requests 44 Actions Projects Security Insights Settings Back to pull request #87 test cross #108 Jobs Run details Workflow file for this run .github/workflows/pr-checks.yml at 9ad9b7b name

pasted

this is my path-giard.rego     this is my pr0-cehcks see wy error is hitting and rudra1904 is int app-2 team

Looking at your error and the code, I can identify the issue:

The Problem
The error message shows:

rego_parse_error: unexpected some keyword: illegal negation of 'some'
not some allowed in allowed_paths_for_app_teams; startswith(fp, allowed)
This is a syntax error in your Rego policy. The issue is on this line in path_guard.rego:

rego
not some allowed in allowed_paths_for_app_teams; startswith(fp, allowed)
Why It's Failing
In Rego, you cannot use not some directly like this. The negation operator not cannot be applied to a some expression in this way.

The Fix
Replace the problematic section with this corrected version:

rego
deny contains msg if {
  not core_bypass
  valid_files
  some f in input.files
  fp := norm_path(f)
  # Check if file does NOT start with any allowed path
  not startswith_any_allowed_path(fp)
  msg := sprintf("Access denied: %s (app teams can only access: apps/, tenants/dev/, tenants/qa/)", [f])
}

# Helper function to check if path starts with any allowed path
startswith_any_allowed_path(fp) if {
  some allowed in allowed_paths_for_app_teams
  startswith(fp, allowed)
}
Complete Corrected Section
Replace the last rule in your path_guard.rego with:

rego
# -------- allowed paths for app teams --------
# Define what app teams CAN access (whitelist approach)
allowed_paths_for_app_teams := {"apps/", "tenants/dev/", "tenants/qa/"}

# Helper function to check if path starts with any allowed path
startswith_any_allowed_path(fp) if {
  some allowed in allowed_paths_for_app_teams
  startswith(fp, allowed)
}

deny contains msg if {
  not core_bypass
  valid_files
  some f in input.files
  fp := norm_path(f)
  # Check if file does NOT start with any allowed path
  not startswith_any_allowed_path(fp)
  msg := sprintf("Access denied: %s (app teams can only access: apps/, tenants/dev/, tenants/qa/)", [f])
}
Why Rudra1904 Got Empty Teams
From your screenshot, the team resolution shows:

Found 3 teams in path_guard.rego: app1, app2, ciam-core
But Rudra1904 is not an active member of any of these teams
Result: actor_teams: []
This means even though you say Rudra1904 is in app-2 team, the GitHub API check shows they're not an active member. This could be because:

The team name in path_guard.rego doesn't match the actual GitHub team name
Rudra1904 hasn't accepted the team invitation
The team membership is "pending" rather than "active"
After fixing the Rego syntax error, you should also verify the team membership issue.

adn the teams name arare not  app1, app2 reight they are team-app1,team-app2

Exactly! That's another issue. Looking at your path_guard.rego, the team names in the team_to_app mapping are:

rego
team_to_app := {
  "team-app1": "app1",
  "team-app1-reviewers": "app1",
  "team-app2": "app2",
  "team-app2-reviewers": "app2",
}
But your GitHub Actions workflow is extracting team names incorrectly. Look at this part of the workflow:

bash
# Extract teams from team_to_app mapping
EXTRACTED_TEAMS=$(grep -A 20 'team_to_app :=' base/policies/path_guard.rego | \
  grep -E '^\s*"[^"]+":' | \
  sed 's/.*"\([^"]*\)".*/\1/' | \
  sort -u)
This extracts the keys from team_to_app, which are the correct team names: team-app1, team-app2, etc.

So the workflow should be checking for teams like:

team-app1
team-app1-reviewers
team-app2
team-app2-reviewers
ciam-core
The Real Issue
From your screenshot at line 132-135, it shows:

Found 3 teams in path_guard.rego:
- app1
- app2
- ciam-core
This means the extraction is wrong - it's getting app1 and app2 instead of team-app1 and team-app2.

Two Fixes Needed
1. Fix the Rego syntax error (from my previous response)

2. Verify the team extraction is working correctly

The sed command might be extracting the wrong part. Let me provide a better extraction script:

bash
# Extract teams from team_to_app mapping - get the KEYS (team names)
EXTRACTED_TEAMS=$(grep -A 20 'team_to_app :=' base/policies/path_guard.rego | \
  grep -E '^\s*"[^"]+"\s*:' | \
  sed -E 's/^\s*"([^"]+)"\s*:.*/\1/' | \
  sort -u)
Or even better, test what your current script is actually extracting by running it locally on your path_guard.rego file to see why it's getting app1, app2 instead of team-app1, team-app2.

Once both issues are fixed:

The Rego policy will parse correctly
The workflow will check if Rudra1904 is a member of team-app2 (not just app2)
modify my rego and give me judpaetd pr-chceks.yml

path_guard.rego (Fixed)
Code 
can you use soeme in your reog code ?

path_guard.rego (Fixed)
Code‚ÄÇ‚àô‚ÄÇVersion 2 
Yes! I've updated the Rego code to use some in a more idiomatic way. The key change is in the last rule:

Old version (with helper function):

rego
# Helper function to check if path starts with any allowed path
startswith_any_allowed_path(fp) if {
  some allowed in allowed_paths_for_app_teams
  startswith(fp, allowed)
}

deny contains msg if {
  not startswith_any_allowed_path(fp)
  ...
}
New version (using some directly):

rego
deny contains msg if {
  not core_bypass
  valid_files
  some f in input.files
  fp := norm_path(f)
  # Check if file does NOT start with any allowed path
  count({allowed | some allowed in allowed_paths_for_app_teams; startswith(fp, allowed)}) == 0
  msg := sprintf("Access denied: %s (app teams can only access: apps/, tenants/dev/, tenants/qa/)", [f])
}
This approach:

Uses some within a set comprehension to find matching allowed paths
Counts how many matches exist
If count is 0, then no allowed path matched, so we deny
This is more concise and follows Rego best practices by using some directly in the logic rather than creating a separate helper function.

1759809244969_image.png
but my previosu worfkow throwed error right

You're right! The error is still the same. The issue is that we can't use some inside a set comprehension in that way. Let me fix it properly:

path_guard.rego (Fixed)
Code‚ÄÇ‚àô‚ÄÇVersion 3 
Now I've fixed it properly! The corrected version:

Creates a helper rule path_is_allowed(fp) that uses some correctly
Uses negation not path_is_allowed(fp) to check if the path is NOT allowed
This is the proper Rego pattern. The rule path_is_allowed(fp) will:

Return true if ANY allowed path matches (using some)
Be undefined (which evaluates to false) if no allowed path matches
Then not path_is_allowed(fp) will trigger the deny rule when the path doesn't match any allowed paths.

This avoids the "illegal negation of 'some'" error because we're negating the helper rule, not the some keyword directly.

so what doe shis reog deos

Let me explain what this Rego policy does in simple terms:

Path Guard Policy Overview
This policy acts as a security gatekeeper for Pull Requests, controlling who can modify what files based on their GitHub team membership.

Key Components:
1. Team-to-App Mapping
rego
team_to_app := {
  "team-app1": "app1",
  "team-app1-reviewers": "app1",
  "team-app2": "app2",
  "team-app2-reviewers": "app2",
}
Maps GitHub teams to applications
Example: Members of team-app2 can only work on app2 files
2. Core Team Bypass
rego
core_teams := {"ciam-core"}
core_bypass if { some t; actor_team_set[t]; core_teams[t] }
ciam-core team can access everything
They bypass all restrictions
What It Blocks (Deny Rules):
üö´ 1. Wrong App Access
Access denied: Your team (app: app2) cannot modify files in app: app1
If you're on team-app2, you can ONLY modify files in apps/app2/
You CANNOT touch apps/app1/ files
üö´ 2. Multiple Apps in One PR
Multiple apps touched: [app1, app2]. Limit PR to one app.
Can't modify multiple apps in a single PR
Must create separate PRs for each app
üö´ 3. Wrong Environment Access
Access denied: Only 'dev' environment is allowed. Attempted to access: prod
Non-core teams can ONLY access tenants/dev/
Cannot access tenants/qa/ or tenants/prod/
üö´ 4. Production Access
Prod environment access is not allowed: tenants/prod/config.yml
Prod is completely blocked for non-core teams
Even if they try to access it
üö´ 5. Out-of-Scope App Files
App path out of scope: apps/app1/config.yml (expected apps/app2/)
If the policy determines you should work on app2, but you touch app1 files
Enforces staying within your app boundary
üö´ 6. Unauthorized Path Access
Access denied: base/policies/some-file.yml (app teams can only access: apps/, tenants/dev/, tenants/qa/)
App teams can ONLY access:
apps/ (their specific app)
tenants/dev/
tenants/qa/
Cannot touch base/, root files, or other directories
Example Scenarios:
‚úÖ Allowed:
Rudra1904 (member of team-app2) modifies apps/app2/config.yml ‚Üí PASS
Rudra1904 modifies tenants/dev/tenant1/settings.yml ‚Üí PASS
Core team member modifies anything ‚Üí PASS (bypass)
‚ùå Blocked:
Rudra1904 modifies apps/app1/config.yml ‚Üí FAIL (wrong app)
Rudra1904 modifies tenants/prod/config.yml ‚Üí FAIL (prod blocked)
Rudra1904 modifies base/policies/path_guard.rego ‚Üí FAIL (unauthorized path)
Rudra1904 modifies both apps/app1/ and apps/app2/ ‚Üí FAIL (multiple apps)
How It Determines Your App:
From files you're modifying: If you modify apps/app2/config.yml, it knows you're working on app2
From your team membership: If you're in team-app2, your allowed app is app2
Validation: It checks if the files you're modifying match your team's allowed app
Summary:
This policy enforces least privilege access by:

Restricting teams to their own apps
Preventing production access for app teams
Limiting where teams can make changes
Allowing only the core team full access
It's like a bouncer at a club checking if you're on the list for the right section! üé´

give me my pr-cehcsk upadte again

pr-checks.yml (Fixed)
Code‚ÄÇ‚àô‚ÄÇVersion 2 




name: PR Checks (Conftest)

on:
  pull_request:
    branches: [ main ]
    types: [opened, reopened, synchronize, edited, ready_for_review]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  checks: write

concurrency:
  group: pr-check-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  # ----------------------------
  # 1) SETUP - Install tools once
  # ----------------------------
  setup:
    name: Install Tools
    runs-on: ubuntu-latest
    steps:
      - name: Install Conftest
        shell: bash
        run: |
          set -Eeuo pipefail
          VER="v0.62.0"
          ARCH="$(uname -m)"
          case "$ARCH" in
            x86_64|amd64) ASSET="conftest_${VER#v}_Linux_x86_64.tar.gz" ;;
            aarch64|arm64) ASSET="conftest_${VER#v}_Linux_arm64.tar.gz" ;;
            *) echo "Unsupported arch: $ARCH" >&2; exit 1 ;;
          esac
          URL="https://github.com/open-policy-agent/conftest/releases/download/${VER}/${ASSET}"
          echo "Downloading $URL"
          curl -sSfL "$URL" | tar xz
          chmod +x conftest
          
      - name: Install yq
        shell: bash
        run: |
          VER="v4.44.3"
          curl -sSfL -o yq \
            "https://github.com/mikefarah/yq/releases/download/${VER}/yq_linux_amd64"
          chmod +x yq
          
      - name: Upload binaries
        uses: actions/upload-artifact@v4
        with:
          name: conftest-and-yq-binaries
          path: |
            conftest
            yq
          retention-days: 1

  # ----------------------------
  # 2) PATH GUARD (using cached conftest)
  # ----------------------------
  path-guard:
    name: Path Guard (Conftest)
    runs-on: ubuntu-latest
    needs: [setup]
    env:
      ORG_TOKEN: ${{ secrets.ORG_TOKEN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Download binaries
        uses: actions/download-artifact@v4
        with:
          name: conftest-and-yq-binaries
          path: .
          
      - name: Setup tools
        run: |
          chmod +x conftest yq
          sudo mv conftest /usr/local/bin/
          sudo mv yq /usr/local/bin/
          conftest --version
      - name: Determine base & head
        id: revs
        shell: bash
        run: |
          set -Eeuo pipefail
          BASE="${{ github.event.pull_request.base.sha || '' }}"
          HEAD="${{ github.event.pull_request.head.sha || github.sha }}"
          if [ -z "$BASE" ]; then
            git fetch origin main
            BASE="$(git rev-parse origin/main)"
          fi
          echo "base=$BASE" >> "$GITHUB_OUTPUT"
          echo "head=$HEAD" >> "$GITHUB_OUTPUT"
          echo "BASE=$BASE"
          echo "HEAD=$HEAD"
      - name: Get changed files ‚Üí files.json
        id: changed
        shell: bash
        run: |
          set -Eeuo pipefail
          git diff --name-only "${{ steps.revs.outputs.base }}..${{ steps.revs.outputs.head }}" > /tmp/changed.txt || true
          echo "Changed files:"; cat /tmp/changed.txt || true
          jq -Rsn '[inputs | split("\n")[] | select(length>0)]' < /tmp/changed.txt > /tmp/files.json
          echo "files.json:"; cat /tmp/files.json
      - name: Resolve actor teams (PR author's teams)
        id: teams
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ORG_TOKEN: ${{ secrets.ORG_TOKEN }}
        run: |
          set -euo pipefail
          
          API="https://api.github.com"
          ORG="${{ github.repository_owner }}"
          PR_AUTHOR="${{ github.event.pull_request.user.login }}"
          
          echo "=========================================="
          echo "üîé Resolving teams for PR author: $PR_AUTHOR"
          echo "=========================================="
          
          # Check if ORG_TOKEN is available
          if [[ -z "${ORG_TOKEN:-}" ]]; then
            echo "‚ùå ERROR: ORG_TOKEN is not set"
            echo "   Team-based path guards will not work."
            echo "   Please add ORG_TOKEN secret with 'read:org' permission."
            echo "[]" > /tmp/actor_teams.json
            echo "actor_teams:"; cat /tmp/actor_teams.json
            exit 0
          fi
          
          echo "‚úÖ ORG_TOKEN is available"
          
          # Verify PR author exists using GITHUB_TOKEN
          echo ""
          echo "üìã Step 1: Verifying PR author exists..."
          user_check=$(curl -sSL -w "%{http_code}" -o /tmp/user_check.json \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "$API/users/$PR_AUTHOR" 2>/dev/null || echo "000")
          
          if [[ "$user_check" != "200" ]]; then
            echo "‚ùå ERROR: Could not verify user $PR_AUTHOR (status: $user_check)"
            echo "[]" > /tmp/actor_teams.json
            exit 0
          fi
          
          user_name=$(jq -r '.name // .login' /tmp/user_check.json)
          echo "‚úÖ User verified: $user_name ($PR_AUTHOR)"
          
          # Extract teams from path_guard.rego - FIXED VERSION
          echo ""
          echo "üìã Step 2: Extracting teams from path_guard.rego..."
          TEAMS_TO_CHECK=()
          
          if [ -f "base/policies/path_guard.rego" ]; then
            # Extract team KEYS from team_to_app mapping (e.g., "team-app1", "team-app2")
            EXTRACTED_TEAMS=$(grep -A 20 'team_to_app :=' base/policies/path_guard.rego | \
              grep -E '^\s*"[^"]+"\s*:' | \
              sed -E 's/^\s*"([^"]+)"\s*:.*/\1/' | \
              sort -u)
            
            # Extract core_teams
            CORE_TEAMS=$(grep -A 5 'core_teams :=' base/policies/path_guard.rego | \
              grep -E '"[^"]+"' | \
              sed -E 's/.*"([^"]+)".*/\1/' | \
              sort -u)
            
            # Combine both
            ALL_TEAMS=$(echo -e "$EXTRACTED_TEAMS\n$CORE_TEAMS" | grep -v '^$' | sort -u)
            
            while IFS= read -r team; do
              [ -n "$team" ] && TEAMS_TO_CHECK+=("$team")
            done <<< "$ALL_TEAMS"
            
            echo "‚úÖ Found ${#TEAMS_TO_CHECK[@]} teams in path_guard.rego:"
            printf '   - %s\n' "${TEAMS_TO_CHECK[@]}"
          else
            echo "‚ùå ERROR: base/policies/path_guard.rego not found"
            echo "[]" > /tmp/actor_teams.json
            exit 0
          fi
          
          # Check team memberships using ORG_TOKEN
          echo ""
          echo "üìã Step 3: Checking team memberships (using ORG_TOKEN)..."
          USER_TEAMS=()
          
          for team in "${TEAMS_TO_CHECK[@]}"; do
            team_status=$(curl -sSL -o /tmp/${team}.json -w "%{http_code}" \
              -H "Authorization: Bearer $ORG_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              "$API/orgs/$ORG/teams/$team/memberships/$PR_AUTHOR" 2>/dev/null || echo "000")
            
            tstate=$(jq -r '.state // empty' /tmp/${team}.json 2>/dev/null || echo "")
            
            if [[ "$team_status" == "200" ]]; then
              if [[ "$tstate" == "active" ]]; then
                USER_TEAMS+=("$team")
                echo "   ‚úÖ $team (active)"
              else
                echo "   ‚ö†Ô∏è  $team (status: $tstate)"
              fi
            elif [[ "$team_status" == "404" ]]; then
              echo "   ‚ö™ $team (not a member)"
            else
              echo "   ‚ùå $team (HTTP $team_status - API error)"
              if [[ "$team_status" == "000" ]]; then
                echo "      ‚ö†Ô∏è  Network error or invalid token"
              fi
            fi
          done
          
          # Convert to JSON array
          echo ""
          if [ ${#USER_TEAMS[@]} -eq 0 ]; then
            echo "‚ö†Ô∏è  No active team memberships found for $PR_AUTHOR"
            echo "[]" > /tmp/actor_teams.json
          else
            printf '%s\n' "${USER_TEAMS[@]}" | jq -R . | jq -s 'map(ascii_downcase)' > /tmp/actor_teams.json
            echo "‚úÖ Found ${#USER_TEAMS[@]} active team membership(s)"
          fi
          
          echo ""
          echo "=========================================="
          echo "Final result:"
          cat /tmp/actor_teams.json
          echo "=========================================="
      - name: Build input.json for Path Guard
        id: input
        shell: bash
        run: |
          set -Eeuo pipefail
          jq -n \
            --slurpfile files /tmp/files.json \
            --slurpfile teams /tmp/actor_teams.json \
            --argjson debug false \
            '{debug:$debug, files:$files[0], actor_teams:$teams[0]}' > input.json
          echo "input.json:"; cat input.json
      - name: Run Path Guard policy
        shell: bash
        run: |
          set -Eeuo pipefail
          conftest test \
            --namespace pr.pathguard \
            --policy base/policies \
            "${{ github.workspace }}/input.json"
      - name: Upload input.json (artifact)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: conftest-input
          path: input.json
          retention-days: 7

  # ------------------------------------
  # 3) BASELINE CONFIGURATION VALIDATION
  # ------------------------------------
  baseline-config-validation:
    name: Baseline Config Validation
    runs-on: ubuntu-latest
    needs: [setup, path-guard]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Download binaries
        uses: actions/download-artifact@v4
        with:
          name: conftest-and-yq-binaries
          path: .
          
      - name: Setup tools
        run: |
          chmod +x conftest yq
          sudo mv conftest /usr/local/bin/
          sudo mv yq /usr/local/bin/
          conftest --version
          yq --version
      - name: Check for baseline config changes
        id: check-changes
        shell: bash
        run: |
          set -Eeuo pipefail
          BASE="${{ github.event.pull_request.base.sha || '' }}"
          HEAD="${{ github.event.pull_request.head.sha || github.sha }}"
          if [ -z "$BASE" ]; then
            git fetch origin main
            BASE="$(git rev-parse origin/main)"
          fi
          if git diff --name-only "$BASE..$HEAD" | grep -E '^base/base-line/(configs|validators)/.*\.ya?ml$' > /dev/null; then
            echo "baseline-changes=true" >> "$GITHUB_OUTPUT"
            echo "Baseline configuration changes detected"
          else
            echo "baseline-changes=false" >> "$GITHUB_OUTPUT"
            echo "No baseline configuration changes detected"
          fi
      - name: Merge and validate baseline configs
        if: steps.check-changes.outputs.baseline-changes == 'true'
        shell: bash
        run: |
          set -Eeuo pipefail
          
          echo "=========================================="
          echo "Baseline Configuration Validation"
          echo "=========================================="
          echo ""
          
          mkdir -p temp
          
          echo "Merging baseline configs..."
          yq eval-all '. as $item ireduce ({}; . * $item)' \
            base/base-line/configs/app-oidc.yml \
            base/base-line/configs/auth-settings.yml \
            base/base-line/configs/risk-settings.yml \
            base/base-line/configs/ux-settings.yml > temp/merged-config.yaml
          
          echo "Merging baseline standards..."
          yq eval-all '. as $item ireduce ({}; . * $item)' \
            base/base-line/validators/app-oidc-standard.yaml \
            base/base-line/validators/auth-settings-standard.yaml \
            base/base-line/validators/risk-settings-standard.yaml \
            base/base-line/validators/ux-settings-standard.yaml > temp/merged-standard.yaml
          
          echo "Creating combined input file..."
          cat > temp/baseline-input.yaml <<EOF
          config:
          $(cat temp/merged-config.yaml | sed 's/^/  /')
          standard:
          $(cat temp/merged-standard.yaml | sed 's/^/  /')
          EOF
          
          echo "Running Conftest validation..."
          if conftest test temp/baseline-input.yaml \
            --policy base/base-line/policies/ \
            --no-color; then
            echo ""
            echo "=========================================="
            echo "‚úÖ Baseline validation PASSED"
            echo "=========================================="
          else
            echo ""
            echo "=========================================="
            echo "‚ùå Baseline validation FAILED"
            echo "=========================================="
            exit 1
          fi
      - name: Skip validation message
        if: steps.check-changes.outputs.baseline-changes == 'false'
        shell: bash
        run: |
          echo "No baseline configuration changes detected in this PR."
          echo "Skipping baseline configuration validation."
  # ------------------------------------
  # 4) TENANT-LEVEL CONFIGURATION VALIDATION
  # ------------------------------------
  tenant-config-validation:
    name: Tenant Config Validation
    runs-on: ubuntu-latest
    needs: [setup, path-guard]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Download binaries
        uses: actions/download-artifact@v4
        with:
          name: conftest-and-yq-binaries
          path: .
          
      - name: Setup tools
        run: |
          chmod +x conftest yq
          sudo mv conftest /usr/local/bin/
          sudo mv yq /usr/local/bin/
          conftest --version
          yq --version
      - name: Check for tenant config changes
        id: check-changes
        shell: bash
        run: |
          set -Eeuo pipefail
          BASE="${{ github.event.pull_request.base.sha || '' }}"
          HEAD="${{ github.event.pull_request.head.sha || github.sha }}"
          if [ -z "$BASE" ]; then
            git fetch origin main
            BASE="$(git rev-parse origin/main)"
          fi
          if git diff --name-only "$BASE..$HEAD" | grep -E '^tenants/(dev|qa|prod)/tenant.*\.yml$' > /dev/null; then
            echo "tenant-changes=true" >> "$GITHUB_OUTPUT"
            echo "Tenant configuration changes detected"
          else
            echo "tenant-changes=false" >> "$GITHUB_OUTPUT"
            echo "No tenant configuration changes detected"
          fi
      - name: Validate tenant configurations
        if: steps.check-changes.outputs.tenant-changes == 'true'
        shell: bash
        run: |
          set -Eeuo pipefail
          cd tenants
          
          ENVIRONMENTS=("dev" "qa" "prod")
          VALIDATION_FAILED=false
          
          for ENV in "${ENVIRONMENTS[@]}"; do
            echo "Merging configs for environment: $ENV"
            
            # Clean up any existing merged files
            rm -f ${ENV}-tenant*-combined.yml
            
            if [ ! -d "$ENV" ]; then
              echo "Warning: Environment directory '$ENV' not found, skipping..."
              continue
            fi
            
            # Loop through all tenant directories
            for tenant_dir in ${ENV}/tenant*/; do
              if [ -d "$tenant_dir" ]; then
                tenant_name=$(basename "$tenant_dir")
                echo "Processing $tenant_name..."
                
                # Check if YAML files exist
                if ls ${tenant_dir}/*.yml 1> /dev/null 2>&1; then
                  # Merge all YAML files for this tenant
                  yq eval-all '. as $item ireduce ({}; . * $item)' \
                    ${tenant_dir}/*.yml \
                    > ${ENV}-${tenant_name}-combined.yml
                  
                  echo "‚úì Created ${ENV}-${tenant_name}-combined.yml"
                else
                  echo "‚ö† No YAML files found in $tenant_dir"
                fi
              fi
            done
            
            # Check if we have any merged files to validate
            if ls ${ENV}-tenant*-combined.yml 1> /dev/null 2>&1; then
              echo ""
              echo "Running conftest validation for $ENV..."
              
              if conftest test --policy overlays/policies/ --data overlays/validators/ ${ENV}-tenant*-combined.yml; then
                echo "‚úÖ $ENV environment validation PASSED"
              else
                echo "‚ùå $ENV environment validation FAILED"
                VALIDATION_FAILED=true
              fi
            else
              echo "No merged files found for $ENV environment"
            fi
            
            # Clean up
            rm -f ${ENV}-tenant*-combined.yml
          done
          
          if [ "$VALIDATION_FAILED" = true ]; then
            echo "One or more environment validations failed"
            exit 1
          else
            echo "All tenant configurations comply with enterprise security standards"
          fi
      - name: Skip validation message
        if: steps.check-changes.outputs.tenant-changes == 'false'
        shell: bash
        run: |
          echo "No tenant configuration changes detected in this PR."
          echo "Skipping tenant configuration validation."
  # ------------------------------------
  # 5) APP-LEVEL CONFIGURATION VALIDATION
  # ------------------------------------
  app-level-validation:
    name: App-Level Config Validation
    runs-on: ubuntu-latest
    needs: [setup, path-guard]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Download binaries
        uses: actions/download-artifact@v4
        with:
          name: conftest-and-yq-binaries
          path: .
          
      - name: Setup tools
        run: |
          chmod +x conftest yq
          sudo mv conftest /usr/local/bin/
          sudo mv yq /usr/local/bin/
          conftest --version
          yq --version
      - name: Check for app config changes
        id: check-changes
        shell: bash
        run: |
          set -Eeuo pipefail
          BASE="${{ github.event.pull_request.base.sha || '' }}"
          HEAD="${{ github.event.pull_request.head.sha || github.sha }}"
          if [ -z "$BASE" ]; then
            git fetch origin main
            BASE="$(git rev-parse origin/main)"
          fi
          if git diff --name-only "$BASE..$HEAD" | grep -E '^apps/[^/]+/(tokens|security|orgs)\.yml$' > /dev/null; then
            echo "app-changes=true" >> "$GITHUB_OUTPUT"
            echo "App configuration changes detected"
          else
            echo "app-changes=false" >> "$GITHUB_OUTPUT"
            echo "No app configuration changes detected"
          fi
      - name: Validate app configurations
        if: steps.check-changes.outputs.app-changes == 'true'
        shell: bash
        run: |
          set -Eeuo pipefail
          
          VALIDATION_FAILED=false
          TOTAL_APPS=0
          PASSED_APPS=0
          FAILED_APPS=0
          
          echo "=========================================="
          echo "App Configuration Validation"
          echo "=========================================="
          echo ""
          
          # Loop through all app directories
          for app_dir in apps/*/; do
            if [ -d "$app_dir" ]; then
              app_name=$(basename "$app_dir")
              TOTAL_APPS=$((TOTAL_APPS + 1))
              
              echo "Processing: $app_name"
              echo "----------------------------------------"
              
              # Determine app type
              APP_TYPE="spa"
              if [[ "$app_name" == *"app2"* ]] || [[ "$app_name" == *"web"* ]]; then
                APP_TYPE="regular_web"
              elif [[ "$app_name" == *"mobile"* ]] || [[ "$app_name" == *"native"* ]]; then
                APP_TYPE="native"
              fi
              
              echo "App type: $APP_TYPE"
              
              # Check if required files exist
              if [ ! -f "${app_dir}/tokens.yml" ] || [ ! -f "${app_dir}/security.yml" ] || [ ! -f "${app_dir}/orgs.yml" ]; then
                echo "‚ö†Ô∏è  Missing required YAML files in ${app_dir}"
                echo "Required files: tokens.yml, security.yml, orgs.yml"
                FAILED_APPS=$((FAILED_APPS + 1))
                VALIDATION_FAILED=true
                continue
              fi
              
              # Create combined config
              OUTPUT_FILE="${app_dir}/${app_name}-combined.yml"
              
              cat > ${OUTPUT_FILE} <<EOF
          app_type: "${APP_TYPE}"
          tokens:
          $(yq eval '.' ${app_dir}/tokens.yml | sed 's/^/  /')
          security:
          $(yq eval '.' ${app_dir}/security.yml | sed 's/^/  /')
          orgs:
          $(yq eval '.' ${app_dir}/orgs.yml | sed 's/^/  /')
          EOF
              
              echo "‚úì Created ${OUTPUT_FILE}"
              
              # Run validation
              echo "Validating ${app_name}..."
              if conftest test \
                  --policy base/policies/ \
                  --data base/tenants-common \
                  ${OUTPUT_FILE}; then
                PASSED_APPS=$((PASSED_APPS + 1))
                echo "‚úÖ PASS: $app_name"
              else
                FAILED_APPS=$((FAILED_APPS + 1))
                echo "‚ùå FAIL: $app_name"
                VALIDATION_FAILED=true
              fi
              
              echo ""
            fi
          done
          
          echo "=========================================="
          echo "Validation Summary"
          echo "=========================================="
          echo "Total Apps:   $TOTAL_APPS"
          echo "Passed:       $PASSED_APPS"
          echo "Failed:       $FAILED_APPS"
          echo "=========================================="
          
          if [ "$VALIDATION_FAILED" = true ]; then
            echo "One or more app validations failed"
            exit 1
          else
            echo "All app configurations comply with standards"
          fi
      - name: Skip validation message
        if: steps.check-changes.outputs.app-changes == 'false'
        shell: bash
        run: |
          echo "No app configuration changes detected in this PR."
          echo "Skipping app configuration validation."
  # ------------------------------------
  # 6) SHARED-SEC POLICIES (Conftest validation)
  # ------------------------------------
  shared-sec-policies:
    name: Shared-Sec Policies (Conftest)
    runs-on: ubuntu-latest
    needs: [setup, path-guard, baseline-config-validation, tenant-config-validation, app-level-validation]
    if: always()
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Download binaries
        uses: actions/download-artifact@v4
        with:
          name: conftest-and-yq-binaries
          path: .
          
      - name: Setup tools
        run: |
          chmod +x conftest yq
          sudo mv conftest /usr/local/bin/
          sudo mv yq /usr/local/bin/
          conftest --version
          yq --version

      - name: Validate Security Policies for All Apps
        shell: bash
        run: |
          set -Eeuo pipefail
          
          echo "=========================================="
          echo "Validating Security Policies for All Apps"
          echo "=========================================="
          echo ""
          
          FAILED=0
          TOTAL_APPS=0
          PASSED_APPS=0
          
          # Loop through all apps and create combined files
          for app_dir in apps/*/; do
            if [ -d "$app_dir" ]; then
              app_name=$(basename "$app_dir")
              TOTAL_APPS=$((TOTAL_APPS + 1))
              
              echo "Processing app: $app_name"
              echo "----------------------------------------"
              
              # Determine app type
              APP_TYPE="spa"
              if [[ "$app_name" == *"app2"* ]] || [[ "$app_name" == *"web"* ]]; then
                APP_TYPE="regular_web"
              elif [[ "$app_name" == *"mobile"* ]] || [[ "$app_name" == *"native"* ]]; then
                APP_TYPE="native"
              fi
              
              # Check if required files exist
              if [ ! -f "${app_dir}/tokens.yml" ] || [ ! -f "${app_dir}/security.yml" ] || [ ! -f "${app_dir}/orgs.yml" ]; then
                echo "‚ö†Ô∏è  Missing required YAML files, skipping..."
                continue
              fi
              
              # Create combined config
              OUTPUT_FILE="${app_dir}/${app_name}-combined.yml"
              
              cat > ${OUTPUT_FILE} <<EOF
          app_type: "${APP_TYPE}"
          tokens:
          $(yq eval '.' ${app_dir}/tokens.yml | sed 's/^/  /')
          security:
          $(yq eval '.' ${app_dir}/security.yml | sed 's/^/  /')
          orgs:
          $(yq eval '.' ${app_dir}/orgs.yml | sed 's/^/  /')
          EOF
              
              echo "‚úì Created ${OUTPUT_FILE}"
              
              # Run shared-sec validation
              echo "Validating security policies..."
              if conftest test \
                --policy overlays/policies/shared_sec.rego \
                --data overlays/shared-sec/identity_access.yml \
                ${OUTPUT_FILE}; then
                PASSED_APPS=$((PASSED_APPS + 1))
                echo "‚úÖ PASSED: $app_name"
              else
                echo "‚ùå FAILED: $app_name violates security policy"
                FAILED=1
              fi
              
              echo ""
            fi
          done
          
          echo "=========================================="
          echo "App Security Validation Summary"
          echo "=========================================="
          echo "Total Apps:   $TOTAL_APPS"
          echo "Passed:       $PASSED_APPS"
          echo "Failed:       $((TOTAL_APPS - PASSED_APPS))"
          echo "=========================================="
          
          if [ $FAILED -eq 1 ]; then
            exit 1
          fi

      - name: Validate Security Policies for All Tenants
        shell: bash
        run: |
          set -Eeuo pipefail
          
          echo "=========================================="
          echo "Validating Security Policies for All Tenants"
          echo "=========================================="
          echo ""
          
          cd tenants
          FAILED=0
          TOTAL_TENANTS=0
          PASSED_TENANTS=0
          ENVIRONMENTS=("dev" "qa" "prod")
          
          # Loop through all environments
          for ENV in "${ENVIRONMENTS[@]}"; do
            if [ ! -d "$ENV" ]; then
              echo "Warning: Environment directory '$ENV' not found, skipping..."
              continue
            fi
            
            echo "Processing environment: $ENV"
            echo "----------------------------------------"
            
            # Clean up any existing merged files
            rm -f ${ENV}-tenant*-combined.yml
            
            # Loop through all tenant directories and merge
            for tenant_dir in ${ENV}/tenant*/; do
              if [ -d "$tenant_dir" ]; then
                tenant_name=$(basename "$tenant_dir")
                TOTAL_TENANTS=$((TOTAL_TENANTS + 1))
                
                echo "Processing tenant: $tenant_name"
                
                # Check if YAML files exist
                if ls ${tenant_dir}/*.yml 1> /dev/null 2>&1; then
                  # Merge all YAML files for this tenant
                  yq eval-all '. as $item ireduce ({}; . * $item)' \
                    ${tenant_dir}/*.yml \
                    > ${ENV}-${tenant_name}-combined.yml
                  
                  echo "‚úì Created ${ENV}-${tenant_name}-combined.yml"
                  
                  # Run shared-sec validation
                  echo "Validating security policies..."
                  if conftest test \
                    --policy ../overlays/policies/shared_sec.rego \
                    --data ../overlays/shared-sec/identity_access.yml \
                    ${ENV}-${tenant_name}-combined.yml; then
                    PASSED_TENANTS=$((PASSED_TENANTS + 1))
                    echo "‚úÖ PASSED: ${ENV}/${tenant_name}"
                  else
                    echo "‚ùå FAILED: ${ENV}/${tenant_name} violates security policy"
                    FAILED=1
                  fi
                else
                  echo "‚ö†Ô∏è  No YAML files found in $tenant_dir"
                fi
                echo ""
              fi
            done
            
            # Clean up merged files for this environment
            rm -f ${ENV}-tenant*-combined.yml
          done
          
          echo "=========================================="
          echo "Tenant Security Validation Summary"
          echo "=========================================="
          echo "Total Tenants: $TOTAL_TENANTS"
          echo "Passed:        $PASSED_TENANTS"
          echo "Failed:        $((TOTAL_TENANTS - PASSED_TENANTS))"
          echo "=========================================="
          
          if [ $FAILED -eq 1 ]; then
            exit 1
          fi
